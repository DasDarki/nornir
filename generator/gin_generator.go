package generator

import (
	"go/ast"
	"nornir/analyzer"
	"nornir/annotations"
	"nornir/log"
	"os"
	"path"
	"path/filepath"
	"regexp"
	"strings"
)

type app struct {
	controller
	ControllerList []*controller `json:"controllers"`
}

type controller struct {
	Imports []string `json:"imports"`
	Dir     string   `json:"dir"`
	Pack    string   `json:"package"`
	Path    string   `json:"path"`
	Routes  []*route `json:"routes"`
}

type route struct {
	Dir       string        `json:"dir"`
	Package   string        `json:"package"`
	Method    string        `json:"method"`
	Path      string        `json:"path"`
	Signature *ast.FuncType `json:"-"`
	Funcname  string        `json:"funcname"`
	Usage     *usage        `json:"usage"`
}

type group struct {
	Imports        []string      `json:"imports"`
	Dir            string        `json:"dir"`
	Pack           string        `json:"package"`
	ControllerList []*controller `json:"controllers"`
	Routes         []*route      `json:"routes"`
}

type usage struct {
	FullPath string
	Method   string
	Name     string
	Params   []string
	Header   []string
	Query    map[string]string
	Body     *string
	Response *string
}

func GenerateGinCode(a *analyzer.Analyzer) []usage {
	usages := []usage{}

	currDir, err := os.Getwd()
	if err != nil {
		panic(err)
	}

	app := structureApp(a, currDir)
	groups := sortAppByPackage(app, a.ModName)

	imports := []string{}
	initCode := []string{}

	for _, group := range groups {
		log.Debugf("Generating group for package %s", group.Pack)
		pack, packname, groupUsages := generateGroup(group, a.ModName)

		if packname != "main" {
			imports = append(imports, "\t\""+pack+"\"")
			initCode = append(initCode, packname+".InitializeController(r)")
		} else {
			initCode = append(initCode, "InitializeController(r)")
		}

		usages = append(usages, groupUsages...)
	}

	content := []string{
		"package main",
		"",
		"import (",
		"\t\"github.com/gin-gonic/gin\"",
	}

	content = addArray(content, imports...)
	content = addArray(content, ")", "")
	content = addArray(content, "", "func initializeAPI(r *gin.Engine) {")
	content = addArray(content, appendToStrings(initCode, "\t")...)
	content = addArray(content, "}", "")

	outfile := path.Join(currDir, cfg.Prefix+"api.go")

	log.Debugf("Generating %s", outfile)

	file, err := os.Create(outfile)
	if err != nil {
		panic(err)
	}

	defer file.Close()

	file.WriteString("/* This file was generated by Nornir */\n\n")

	for _, line := range content {
		file.WriteString(line + "\n")
	}

	file.Sync()

	return usages
}

func generateGroup(group *group, modname string) (string, string, []usage) {
	usages := []usage{}

	packageName := getPackageName(group.Pack)
	if packageName == modname {
		packageName = "main"
	}

	content := []string{
		"package " + packageName,
		"",
		"import (",
		"	\"net/http\"",
		"	\"github.com/gin-gonic/gin\"",
	}

	for _, imp := range group.Imports {
		content = append(content, "	\""+imp+"\"")
	}

	vars := []string{}
	initBody := []string{}
	handlerCode := []string{}
	strconv := false

	for _, r := range group.Routes {
		code, usedStrconv := generateHandler(r, nil)
		handlerCode = append(handlerCode, code...)
		initBody = append(initBody, generateInitForHandler(r, "r"))

		if usedStrconv {
			strconv = true
		}

		if r.Usage != nil {
			usages = append(usages, *r.Usage)
		}
	}

	for _, c := range group.ControllerList {
		if len(c.Routes) == 0 {
			continue
		}

		controllerName := urlPathToGoIdentifier(c.Path) + "Controller"

		vars = append(vars, "var "+controllerName+" *gin.RouterGroup")
		initBody = append(initBody, controllerName+" = r.Group(\""+c.Path+"\")")

		for _, r := range c.Routes {
			code, usedStrconv := generateHandler(r, c)
			handlerCode = append(handlerCode, code...)
			initBody = append(initBody, generateInitForHandler(r, controllerName))

			if usedStrconv {
				strconv = true
			}

			if r.Usage != nil {
				usages = append(usages, *r.Usage)
			}
		}
	}

	if strconv {
		content = addArray(content, "	\"strconv\"")
	}

	content = addArray(content, ")", "")

	content = addArray(content, vars...)
	content = addArray(content, "", "func InitializeController(r *gin.Engine) {")
	content = addArray(content, appendToStrings(initBody, "\t")...)
	content = addArray(content, "}")
	content = addArray(content, handlerCode...)

	outfile := path.Join(group.Dir, cfg.Prefix+"controller.go")

	log.Debugf("Generating %s", outfile)

	file, err := os.Create(outfile)
	if err != nil {
		panic(err)
	}

	defer file.Close()

	file.WriteString("/* This file was generated by Nornir */\n\n")

	for _, line := range content {
		file.WriteString(line + "\n")
	}

	file.Sync()

	return group.Pack, packageName, usages
}

func generateInitForHandler(r *route, groupName string) string {
	if r.Method == "GET" {
		return groupName + ".GET(\"" + r.Path + "\", " + cfg.Prefix + r.Funcname + ")"
	} else if r.Method == "POST" {
		return groupName + ".POST(\"" + r.Path + "\", " + cfg.Prefix + r.Funcname + ")"
	} else if r.Method == "PUT" {
		return groupName + ".PUT(\"" + r.Path + "\", " + cfg.Prefix + r.Funcname + ")"
	} else if r.Method == "DELETE" {
		return groupName + ".DELETE(\"" + r.Path + "\", " + cfg.Prefix + r.Funcname + ")"
	} else if r.Method == "PATCH" {
		return groupName + ".PATCH(\"" + r.Path + "\", " + cfg.Prefix + r.Funcname + ")"
	} else if r.Method == "OPTIONS" {
		return groupName + ".OPTIONS(\"" + r.Path + "\", " + cfg.Prefix + r.Funcname + ")"
	} else if r.Method == "HEAD" {
		return groupName + ".HEAD(\"" + r.Path + "\", " + cfg.Prefix + r.Funcname + ")"
	}

	panic("Unknown method " + r.Method)
}

func sortAppByPackage(app *app, modname string) map[string]*group {
	groups := make(map[string]*group)

	for _, r := range app.Routes {
		if _, ok := groups[r.Package]; !ok {
			groups[r.Package] = &group{
				Imports:        []string{},
				Dir:            r.Dir,
				Pack:           r.Package,
				ControllerList: []*controller{},
				Routes:         []*route{},
			}
		}

		groups[r.Package].Routes = append(groups[r.Package].Routes, r)
	}

	for _, c := range app.ControllerList {
		if _, ok := groups[c.Pack]; !ok {
			groups[c.Pack] = &group{
				Imports:        []string{},
				Dir:            c.Dir,
				Pack:           c.Pack,
				ControllerList: []*controller{},
				Routes:         []*route{},
			}
		}

		groups[c.Pack].ControllerList = append(groups[c.Pack].ControllerList, c)

		for _, i := range c.Imports {
			if strings.HasPrefix(i, modname) && !containsArray(groups[c.Pack].Imports, i) {
				groups[c.Pack].Imports = append(groups[c.Pack].Imports, i)
			}
		}
	}

	return groups

}

func structureApp(a *analyzer.Analyzer, currDir string) *app {
	app := &app{
		controller: controller{
			Dir:    currDir,
			Pack:   a.ModName,
			Path:   "",
			Routes: []*route{},
		},
		ControllerList: []*controller{},
	}

	createdControllers := make(map[string]*controller)
	finishedFiles := make(map[string]bool)

	for _, file := range a.AnnotatedFiles {
		for _, fileAnnotation := range file.Annotations {
			if controllerAnnotation, ok := fileAnnotation.(*annotations.ControllerAnnotation); ok {
				controllerKey := file.Meta.Package + "@" + controllerAnnotation.Path
				if _, ok := createdControllers[controllerKey]; !ok {
					controller := &controller{
						Imports: []string{},
						Dir:     getDirectoryOfFile(file.Meta.Filename),
						Pack:    file.Meta.Package,
						Path:    removeQuotes(controllerAnnotation.Path),
						Routes:  []*route{},
					}
					app.ControllerList = append(app.ControllerList, controller)
					createdControllers[controllerKey] = controller

					for _, importSpec := range file.File.Imports {
						controller.Imports = append(controller.Imports, removeQuotes(importSpec.Path.Value))
					}
				}

				controller := createdControllers[controllerKey]
				for _, function := range a.AnnotatedFuncs {
					if function.Meta.FileId == file.Meta.FileId {
						addRoutesToController(controller, function)
						finishedFiles[file.Meta.FileId] = true
					}
				}
			}
		}
	}

	for _, function := range a.AnnotatedFuncs {
		if _, ok := finishedFiles[function.Meta.FileId]; !ok {
			addRoutesToController(&app.controller, function)
		}
	}

	return app
}

func addRoutesToController(controller *controller, function *annotations.AnnotatedFunc) {
	for _, funcAnnotation := range function.Annotations {
		if requestMappingAnnotation, ok := funcAnnotation.(*annotations.RequestMappingAnnotation); ok {
			controller.Routes = append(controller.Routes, &route{
				Dir:       getDirectoryOfFile(function.Meta.Filename),
				Package:   function.Meta.Package,
				Method:    removeQuotes(requestMappingAnnotation.Method),
				Path:      removeQuotes(requestMappingAnnotation.Path),
				Signature: function.Func.Type,
				Funcname:  function.Func.Name.Name,
			})
		} else if getAnnotation, ok := funcAnnotation.(*annotations.GetAnnotation); ok {
			controller.Routes = append(controller.Routes, &route{
				Dir:       getDirectoryOfFile(function.Meta.Filename),
				Package:   function.Meta.Package,
				Method:    "GET",
				Path:      removeQuotes(getAnnotation.Path),
				Signature: function.Func.Type,
				Funcname:  function.Func.Name.Name,
			})
		} else if postAnnotation, ok := funcAnnotation.(*annotations.PostAnnotation); ok {
			controller.Routes = append(controller.Routes, &route{
				Dir:       getDirectoryOfFile(function.Meta.Filename),
				Package:   function.Meta.Package,
				Method:    "POST",
				Path:      removeQuotes(postAnnotation.Path),
				Signature: function.Func.Type,
				Funcname:  function.Func.Name.Name,
			})
		} else if putAnnotation, ok := funcAnnotation.(*annotations.PutAnnotation); ok {
			controller.Routes = append(controller.Routes, &route{
				Dir:       getDirectoryOfFile(function.Meta.Filename),
				Package:   function.Meta.Package,
				Method:    "PUT",
				Path:      removeQuotes(putAnnotation.Path),
				Signature: function.Func.Type,
				Funcname:  function.Func.Name.Name,
			})
		} else if deleteAnnotation, ok := funcAnnotation.(*annotations.DeleteAnnotation); ok {
			controller.Routes = append(controller.Routes, &route{
				Dir:       getDirectoryOfFile(function.Meta.Filename),
				Package:   function.Meta.Package,
				Method:    "DELETE",
				Path:      removeQuotes(deleteAnnotation.Path),
				Signature: function.Func.Type,
				Funcname:  function.Func.Name.Name,
			})
		} else if patchAnnotation, ok := funcAnnotation.(*annotations.PatchAnnotation); ok {
			controller.Routes = append(controller.Routes, &route{
				Dir:       getDirectoryOfFile(function.Meta.Filename),
				Package:   function.Meta.Package,
				Method:    "PATCH",
				Path:      removeQuotes(patchAnnotation.Path),
				Signature: function.Func.Type,
				Funcname:  function.Func.Name.Name,
			})
		} else if headAnnotation, ok := funcAnnotation.(*annotations.HeadAnnotation); ok {
			controller.Routes = append(controller.Routes, &route{
				Dir:       getDirectoryOfFile(function.Meta.Filename),
				Package:   function.Meta.Package,
				Method:    "HEAD",
				Path:      removeQuotes(headAnnotation.Path),
				Signature: function.Func.Type,
				Funcname:  function.Func.Name.Name,
			})
		} else if optionsAnnotation, ok := funcAnnotation.(*annotations.OptionsAnnotation); ok {
			controller.Routes = append(controller.Routes, &route{
				Dir:       getDirectoryOfFile(function.Meta.Filename),
				Package:   function.Meta.Package,
				Method:    "OPTIONS",
				Path:      removeQuotes(optionsAnnotation.Path),
				Signature: function.Func.Type,
				Funcname:  function.Func.Name.Name,
			})
		}
	}
}

func removeQuotes(s string) string {
	if len(s) > 1 && s[0] == '"' && s[len(s)-1] == '"' {
		return s[1 : len(s)-1]
	}

	return s
}

func getDirectoryOfFile(filename string) string {
	return filepath.Dir(filename)
}

func getPackageName(pack string) string {
	if strings.Contains(pack, "/") {
		return filepath.Base(pack)
	}

	return pack
}

func appendToStrings(array []string, prefix string) []string {
	for i, element := range array {
		array[i] = prefix + element
	}

	return array
}

func addArray(array []string, elements ...string) []string {
	return append(array, elements...)
}

func containsArray(array []string, element string) bool {
	for _, e := range array {
		if e == element {
			return true
		}
	}

	return false
}

func urlPathToGoIdentifier(path string) string {
	reg, err := regexp.Compile("[^a-zA-Z0-9]+")
	if err != nil {
		panic(err)
	}

	processedString := reg.ReplaceAllString(path, "_")
	processedString = strings.Trim(processedString, "_")
	if processedString[0] >= '0' && processedString[0] <= '9' {
		processedString = "_" + processedString
	}

	if len(processedString) == 0 {
		panic("The processed string is empty")
	}

	return processedString
}
