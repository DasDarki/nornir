package generator

import (
	"fmt"
	"nornir/log"
	"os"
	"path"
	"strings"
)

var usedNames = make(map[string]int)

func GenerateTypeScriptClient(usages []usage) {
	createFileOnce("client.ts", []string{
		"import axios from 'axios';",
		"",
		"const DOMAIN = 'http://localhost:8080';",
		"",
		"export const restClient = axios.create({",
		"  baseURL: DOMAIN,",
		"});",
		"",
		"export class RestError extends Error {",
		"  constructor(message: string, public status: number, public data: any) {",
		"    super(message);",
		"  }",
		"}",
	})

	body := []string{"/* This file was generated by Nornir */", "", "import { restClient, RestError } from './client';"}

	for _, u := range usages {
		name := createName(&u)

		body = append(body, "", "")

		if u.Response != nil {
			body = append(body, fmt.Sprintf("export type %sResponse = %s;", name, *u.Response))
		}

		if u.Body != nil {
			body = append(body, fmt.Sprintf("export type %sBody = %s;", name, *u.Body))
		}

		body = append(body, "")
		params := []string{}
		returnType := "Promise<void>"

		for _, h := range u.Header {
			params = append(params, fmt.Sprintf("%s: string", h))
		}

		for _, p := range u.Params {
			params = append(params, fmt.Sprintf("%s: string", p))
		}

		for qname, qtype := range u.Query {
			params = append(params, fmt.Sprintf("%s: %s", qname, qtype))
		}

		if u.Body != nil {
			params = append(params, fmt.Sprintf("body: %sBody", name))
		}

		if u.Response != nil {
			returnType = fmt.Sprintf("Promise<%sResponse>", name)
		}

		body = append(body, fmt.Sprintf("export async function %s(%s): %s {", name, strings.Join(params, ", "), returnType))
		body = append(body, fmt.Sprintf("  let url = `%s`;", u.FullPath))

		for _, p := range u.Params {
			body = append(body, fmt.Sprintf("  url = url.replace(`:%s`, %s);", p, p))
		}

		body = append(body, "")
		body = append(body, "  try {")
		body = append(body, "    const response = await restClient.request({")
		body = append(body, "      url,")
		body = append(body, fmt.Sprintf("      method: '%s',", strings.ToLower(u.Method)))
		body = append(body, "      headers: {")

		for _, h := range u.Header {
			body = append(body, fmt.Sprintf("        %s,", h))
		}

		body = append(body, "      },")
		body = append(body, "      params: {")

		for qname := range u.Query {
			body = append(body, fmt.Sprintf("        %s,", qname))
		}

		body = append(body, "      },")

		if u.Body != nil {
			body = append(body, "      data: body,")
		}

		body = append(body, "    });")
		body = append(body, "  } catch (e) {")
		body = append(body, "    if (e.response) {")
		body = append(body, "      throw new RestError(e.response.data.message, e.response.status, e.response.data);")
		body = append(body, "    } else {")
		body = append(body, "      throw e;")
		body = append(body, "    }")
		body = append(body, "  }")
		body = append(body, "")

		if u.Response != nil {
			body = append(body, fmt.Sprintf("  return response.data as %sResponse;", name))
		} else {
			body = append(body, "  return;")
		}

		body = append(body, "}")
	}

	outfile := path.Join(cfg.OutputDir, "api.ts")

	file, err := os.Create(outfile)
	if err != nil {
		panic(err)
	}

	defer file.Close()

	for _, line := range body {
		file.WriteString(line + "\n")
	}

	log.Debugf("Generated %s", outfile)
}

func createFileOnce(filename string, content []string) {
	outfile := path.Join(cfg.OutputDir, filename)

	if _, err := os.Stat(outfile); os.IsNotExist(err) {
		log.Debugf("Generating %s", outfile)

		file, err := os.Create(outfile)
		if err != nil {
			panic(err)
		}

		defer file.Close()

		for _, line := range content {
			file.WriteString(line + "\n")
		}
	}
}

func createName(u *usage) string {
	name := strings.ToUpper(u.Name[0:1]) + u.Name[1:]

	if _, ok := usedNames[name]; ok {
		name = urlToPascalCase(u.FullPath) + name
	}

	if cur, ok := usedNames[name]; ok {
		usedNames[name] = cur + 1
		return fmt.Sprintf("%s%d", name, cur+1)
	} else {
		usedNames[name] = 0
		return name
	}
}

func urlToPascalCase(url string) string {
	parts := strings.Split(url, "/")
	name := ""

	for _, part := range parts {
		trimmed := strings.TrimSpace(part)
		trimmed = strings.TrimPrefix(trimmed, ":")

		if trimmed == "" {
			continue
		}

		name += strings.ToUpper(trimmed[0:1]) + trimmed[1:]
	}

	return name
}
