package generator

import (
	"go/ast"
	"nornir/analyzer"
	"nornir/log"
	"os"
	"path"
	"strings"
)

type typeScriptFile struct {
	imports []string
	content []string
}

func GenerateTypeScriptDTOs(a *analyzer.Analyzer) {
	outdir := path.Join(cfg.OutputDir, "dto")
	outfiles := make(map[string]*typeScriptFile)

	os.MkdirAll(outdir, os.ModePerm)

	for modPath, structType := range a.Structs {
		filename := convertModPathToFilename(strings.TrimSuffix(modPath, "@"+structType.Name), a.ModName)

		if _, ok := outfiles[filename]; !ok {
			outfiles[filename] = &typeScriptFile{
				imports: make([]string, 0),
				content: make([]string, 0),
			}
		}

		file := outfiles[filename]
		content := generateTypeScriptInterface(structType)

		file.content = append(file.content, "")
		file.content = append(file.content, content...)
	}

	for pack, imports := range a.StructImportMap {
		filename := convertModPathToFilename(pack, a.ModName)

		file, ok := outfiles[filename]
		if !ok {
			continue
		}

		for _, imp := range imports {
			if !strings.HasPrefix(imp.Path, a.ModName) {
				continue
			}

			impFilename := convertModPathToFilename(imp.Path, a.ModName)
			if impFilename == filename {
				continue
			}

			if _, ok := outfiles[impFilename]; !ok {
				continue
			}

			importStmt := "import * as " + imp.Name + " from './" + impFilename + "'"
			if !containsArray(file.imports, importStmt) {
				file.imports = append(file.imports, importStmt)
			}
		}
	}

	for filename, data := range outfiles {
		outfile := path.Join(outdir, filename+".ts")

		log.Debugf("Generating %s", outfile)

		file, err := os.Create(outfile)
		if err != nil {
			panic(err)
		}

		defer file.Close()

		file.WriteString("/* This file was generated by Nornir */\n\n")

		for _, imp := range data.imports {
			file.WriteString(imp + "\n")
		}

		for _, line := range data.content {
			file.WriteString(line + "\n")
		}

		file.Sync()

		log.Debugf("Generated %s", outfile)
	}
}

func convertModPathToFilename(modPath string, modName string) string {
	trimmed := strings.TrimPrefix(strings.TrimSpace(strings.TrimPrefix(modPath, modName)), "/")

	filename := strings.ReplaceAll(trimmed, "/", "_")
	if filename == "" {
		filename = "index"
	}

	return filename
}

func generateTypeScriptInterface(s analyzer.Struct) []string {
	lines := make([]string, 0)
	lines = append(lines, "export interface "+s.Name+" {")

	for _, field := range s.Node.Fields.List {
		name := getFieldName(field)
		if name == "" {
			continue
		}

		line := "\t" + name + ": " + generateTypeScriptType(field.Type)
		lines = append(lines, line)
	}

	lines = append(lines, "}")

	return lines
}

func generateTypeScriptType(expr ast.Expr) string {
	switch v := expr.(type) {
	case *ast.Ident:
		return translateGoPrimitivesToTypeScript(v.Name)
	case *ast.StarExpr:
		return generateTypeScriptType(v.X) + " | null"
	case *ast.ArrayType:
		return generateTypeScriptType(v.Elt) + "[]"
	case *ast.MapType:
		return "Map<" + generateTypeScriptType(v.Key) + ", " + generateTypeScriptType(v.Value) + ">"
	case *ast.SelectorExpr:
		return v.X.(*ast.Ident).Name + "." + v.Sel.Name
	case *ast.InterfaceType:
		return "any"
	case *ast.StructType:
		return "(" + generateTypeScriptObjectBody(v) + ")"
	default:
		log.Debugf("Unknown type: %T", expr)
		return "unknown"
	}
}

func generateTypeScriptObjectBody(strct *ast.StructType) string {
	lines := make([]string, 0)

	for _, field := range strct.Fields.List {
		name := getFieldName(field)
		if name == "" {
			continue
		}

		line := name + ": " + generateTypeScriptType(field.Type)
		lines = append(lines, line)
	}

	return "{" + strings.Join(lines, ", ") + "}"
}

func getFieldName(field *ast.Field) string {
	name := ""
	if field.Tag != nil {
		if !strings.Contains(field.Tag.Value, "json") {
			return ""
		}

		tag := strings.Trim(field.Tag.Value, "`")
		tag = strings.TrimPrefix(tag, "json:\"")
		tag = strings.TrimSuffix(tag, "\"")
		tagParts := strings.Split(tag, ",")
		name = tagParts[0]
	}

	if name == "" {
		name = makeNameLowerCamelCase(field.Names[0].Name)
	}

	return name
}

func translateGoPrimitivesToTypeScript(primitive string) string {
	switch primitive {
	case "int", "int8", "int16", "int32", "int64", "uint", "uint32", "uint64", "uintptr", "float32", "float64", "complex64", "complex128", "byte", "rune":
		return "number"
	case "string":
		return "string"
	case "bool":
		return "boolean"
	}

	return primitive
}

func makeNameLowerCamelCase(name string) string {
	return strings.ToLower(name[0:1]) + name[1:]
}
